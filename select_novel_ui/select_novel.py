# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'select_novel.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from PyQt5.QtGui import *
from PyQt5.QtWidgets import *
from threading import Thread
from PyQt5 import QtCore, QtGui, QtWidgets
from select_novel_ui.download_txt import *


class Ui_Dialog_select_novel(object):
    def __init__(self):
        # self.txt=TXT()
        self.url = 'https://m.rmxsba.com/search.html'
        self.main_url = "https://m.rmxsba.com"
        self.headers = {
            'Cookie': '__cfduid=dd50fb1ed80a7d95c26140bec3bf9b0d71620107395; Hm_lvt_ff5a36d21942c35af99271f0b1999352=1620107389; Hm_lpvt_ff5a36d21942c35af99271f0b1999352=1620110682',
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.25 Safari/537.36 Core/1.70.3861.400 QQBrowser/10.7.4313.400'
        }
        self.page_list = []
        self.chapter_list = []
        self.model = ''
        self.Threads=[]  # 线程队列
        ## 设置tableView
        # self.model = QStandardItemModel(4, 2)
        # self.model.setHorizontalHeaderLabels(['书名', '作者'])
        # self.table_view_select_novel = QTableView()
        # # 关联QTableView控件和Model
        # self.table_view_select_novel.setModel(self.model)
        # # 添加数据
        # item11 = QStandardItem('10')
        # item12 = QStandardItem('雷神')
        # self.model.setItem(0, 0, item11)
        # self.model.setItem(0, 1, item12)
        # layout = QVBoxLayout()
        # layout.addWidget(self.table_view_select_novel)
        # self.setLayout(layout)
    def setupUi(self, Dialog_select_novel):
        Dialog_select_novel.setObjectName("Dialog_select_novel")
        Dialog_select_novel.resize(1041, 733)
        Dialog_select_novel.setMouseTracking(False)
        Dialog_select_novel.setTabletTracking(False)
        self.btn_select_novel = QtWidgets.QPushButton(Dialog_select_novel)
        self.btn_select_novel.setGeometry(QtCore.QRect(830, 40, 93, 31))
        self.btn_select_novel.setObjectName("btn_select_novel")
        self.line_select_novel = QtWidgets.QLineEdit(Dialog_select_novel)
        self.line_select_novel.setGeometry(QtCore.QRect(150, 40, 611, 31))
        self.line_select_novel.setText("")
        self.line_select_novel.setObjectName("line_select_novel")
        self.label = QtWidgets.QLabel(Dialog_select_novel)
        self.label.setGeometry(QtCore.QRect(30, 110, 72, 15))
        self.label.setObjectName("label")
        self.label_2 = QtWidgets.QLabel(Dialog_select_novel)
        self.label_2.setGeometry(QtCore.QRect(440, 110, 101, 16))
        self.label_2.setObjectName("label_2")
        self.textEdit_select_novel = QtWidgets.QTextEdit(Dialog_select_novel)
        self.textEdit_select_novel.setEnabled(True)
        self.textEdit_select_novel.setGeometry(QtCore.QRect(20, 140, 401, 571))
        self.textEdit_select_novel.setObjectName("textEdit_select_novel")
        self.tableWidget_select_novel = QtWidgets.QTableWidget(Dialog_select_novel)
        self.tableWidget_select_novel.setGeometry(QtCore.QRect(440, 140, 581, 571))
        self.tableWidget_select_novel.setGridStyle(QtCore.Qt.SolidLine)
        self.tableWidget_select_novel.setObjectName("tableWidget_select_novel")
        self.tableWidget_select_novel.setColumnCount(3)
        self.tableWidget_select_novel.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_select_novel.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_select_novel.setHorizontalHeaderItem(1, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_select_novel.setHorizontalHeaderItem(2, item)
        self.tableWidget_select_novel.horizontalHeader().setVisible(True)
        self.tableWidget_select_novel.horizontalHeader().setCascadingSectionResizes(False)
        self.tableWidget_select_novel.horizontalHeader().setDefaultSectionSize(185)
        self.tableWidget_select_novel.horizontalHeader().setHighlightSections(True)
        self.tableWidget_select_novel.horizontalHeader().setSortIndicatorShown(False)
        self.tableWidget_select_novel.horizontalHeader().setStretchLastSection(True)

        self.retranslateUi(Dialog_select_novel)
        QtCore.QMetaObject.connectSlotsByName(Dialog_select_novel)


    def retranslateUi(self, Dialog_select_novel):
        _translate = QtCore.QCoreApplication.translate
        Dialog_select_novel.setWindowTitle(_translate("Dialog_select_novel", "Dialog"))
        self.btn_select_novel.setText(_translate("Dialog_select_novel", "搜索"))
        self.label.setText(_translate("Dialog_select_novel", "输出日志"))
        self.label_2.setText(_translate("Dialog_select_novel", "爬取信息表，双击实现下载"))
        self.label_2.adjustSize()
        item = self.tableWidget_select_novel.horizontalHeaderItem(0)
        item.setText(_translate("Dialog_select_novel", "书名"))
        item = self.tableWidget_select_novel.horizontalHeaderItem(1)
        item.setText(_translate("Dialog_select_novel", "作者"))
        item = self.tableWidget_select_novel.horizontalHeaderItem(2)
        item.setText(_translate("Dialog_select_novel", "地址"))
        self.tableWidget_select_novel.setEditTriggers(QAbstractItemView.NoEditTriggers)         ## 将tableWeight设置为只读
        self.tableWidget_select_novel.setSelectionBehavior(QAbstractItemView.SelectRows)    ## 将表格设置为全部选中
        self.btn_select_novel.clicked.connect(self.select)
        self.tableWidget_select_novel.doubleClicked.connect(self.download_novel)


    # 获取所有的小说名
    def download_TXT(self, searchkey):
        data = {
            'searchkey': searchkey,
        }
        response = requests.post(self.url, data=data, headers=self.headers)
        # 使用正则表达式获取总页数
        pagePattern = r"value=\"(/search/\d+/\d+.html)\""
        pageStrs = re.findall(pagePattern, response.text)
        for i in range(len(pageStrs)):
            pageStrs[i] = self.main_url + pageStrs[i]  # 得到总的小说页数
        self.textEdit_select_novel.append("已爬取所有页数")

        novel_list = []  # 获取全部小说地址并存到这里面
        for i in range(len(pageStrs)):
            response = requests.post(pageStrs[i], data=data, headers=self.headers, timeout=5)
            # 使用xpath
            html = etree.HTML(response.text)
            book_urls = html.xpath('//p[@class="bookname"]/a/@href')
            book_names = html.xpath('//p[@class="bookname"]/a/text()')
            author_names = html.xpath('//p[@class="data"]//a[@class="layui-btn layui-btn-xs layui-bg-cyan"]/text()')
            contents = html.xpath('//p[@class="intro"]/text()')
            # 得到最小的长度，防止出错
            min_length = len(book_urls)
            if min_length > len(book_names):
                min_length = len(book_names)
            elif min_length > len(author_names):
                min_length = len(author_names)
            elif min_length > len(contents):
                min_length = len(contents)
            for j in range(min_length):
                l = []
                ##### tableweight 循环添加数据
                row_cnt = self.tableWidget_select_novel.rowCount()  # 返回当前行数（尾部）
                self.tableWidget_select_novel.insertRow(row_cnt)  # 尾部插入一行新行表格
                novel_item = QTableWidgetItem(book_names[j])  # 书名
                self.tableWidget_select_novel.setItem(row_cnt, 0, novel_item)
                author_item = QTableWidgetItem(author_names[j]) #作者名
                self.tableWidget_select_novel.setItem(row_cnt, 1, author_item)
                address_item = QTableWidgetItem(self.main_url + book_urls[j]) #地址
                self.tableWidget_select_novel.setItem(row_cnt, 2, address_item)
                ######
                l.append(self.main_url + book_urls[j])
                l.append("小说名：" + book_names[j])
                l.append("作者：" + author_names[j])
                novel_list.append(l)
            time.sleep(0.3)  # 每0.3秒爬一次
            #输出日志到界面中
            self.textEdit_select_novel.append("已爬取第" + str(i + 1) + "页小说，" + "本页一共" + str(min_length) + "本小说")
        self.textEdit_select_novel.append("共爬取了" + str(len(novel_list)) + "本小说")
        # for novel in novel_list:
        #     for n in novel:
        #         time.sleep(0.05)  # 每0.3秒爬一次
        #         self.textEdit_select_novel.append(n)
    def select(self):
        # # 获取输入行中的信息
        try:
            self.textEdit_select_novel.append(self.line_select_novel.text())
            thread_1=Thread(target=self.download_TXT,args=(self.line_select_novel.text(),))
            thread_1.start()
        except:
            self.textEdit_select_novel.append("Error: 无法启动线程")

    ## 获取一本小说所有页数
    def get_all_page(self, novelUrl,save_path):
        response = requests.get(novelUrl, headers=self.headers,timeout=2)
        html = etree.HTML(response.text)
        ## 获取所有的页数 及多少章节
        pages_url = html.xpath('//select/option/@value')
        page_chapter = html.xpath('//select/option/text()')
        page_min_len = min(len(pages_url), len(page_chapter))
        for i in range(page_min_len):
            l = []
            l.append(self.main_url + pages_url[i])
            l.append(page_chapter[i])
            self.page_list.append(l)

        # 爬取所有页的章节
        for page in self.page_list:
            self.textEdit_select_novel.append("获取到" + page[1] + "的地址")
            self.get_page_chapters(page[0],save_path)
            time.sleep(0.5)

    def get_page_chapters(self, page_url,save_path):
        ## 获取本页所有章节的地址
        response = requests.get(page_url, headers=self.headers,timeout=2)
        html = etree.HTML(response.text)
        chapter_url = html.xpath('//ul[@class="read"]/li/a/@href')
        chapter_name = html.xpath('//ul[@class="read"]/li/a/text()')
        min_len = min(len(chapter_name), len(chapter_url))
        chapter_list = []
        for i in range(min_len):
            l = []
            l.append(self.main_url + chapter_url[i])
            l.append(chapter_name[i])
            chapter_list.append(l)
        for chapter in chapter_list:
            time.sleep(0.3)
            self.download_chapter_text(chapter[0],save_path)

    ## 获取本章节的小说内容，并下载
    def download_chapter_text(self, chapter_url,save_path):
        response = requests.get(chapter_url, headers=self.headers,timeout=2)
        html = etree.HTML(response.text)
        title = html.xpath('//h1[@class="headline"]/text()')[0]
        content = html.xpath('//div[@class="content"]/p/text()')
        with open(save_path, 'a', encoding='utf-8')as f:
            f.write(title + '\n')
            for line in content:
                f.write(line + '\n')
            f.write('\n')
        self.textEdit_select_novel.append('已下载 ' + title)

    def download_novel(self,index):
        row=index.row()
        ##双击获取地址
        novel_name=self.tableWidget_select_novel.item(row,0).text()
        novel_author=self.tableWidget_select_novel.item(row,1).text()
        novel_url = self.tableWidget_select_novel.item(row,2).text()
        ## 选择存储文件夹
        save_path = QFileDialog.getExistingDirectory(self, "请选择存储路径", "C:")
        if save_path=='' or save_path=="C:/":
            return
        save_path=save_path+'/'+novel_name+'.txt'
        self.textEdit_select_novel.append("下载地址为："+save_path)
        self.textEdit_select_novel.append("开始下载："+novel_name)
        self.textEdit_select_novel.append("作者："+novel_author)
        # 开启新线程
        thread = Thread(target=self.get_all_page, args=(novel_url,save_path))
        # 将此线程设置为守护线程
        thread.daemon=1
        thread.start()
        # 将线程加入线程队列
        self.Threads.append(thread)
